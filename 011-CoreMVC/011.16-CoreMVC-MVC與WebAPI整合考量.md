---
title: ⚙️ 011.12-CoreMVC-單元測試與自動化
tags:
  - ASP-NET
  - Core
  - MVC
  - 單元測試
  - 自動化
  - 測試驅動開發
aliases:
  - ASP.NET Core 單元測試
  - Unit Test
  - Mock
created: 2025-07-08
updated: 2025-07-08
status: 草稿
summary: 探討 ASP.NET Core MVC 專案中單元測試的重要性與實作方法，包括測試框架的選擇、如何為 Controller 和 Service 進行測試、模擬 (Mock) 依賴，以及將測試整合到自動化流程。
---

## ⚙️ 什麼是單元測試？為什麼它如此重要？

想像一下，在建造一棟複雜的建築物時，如果等到整棟樓都蓋好才發現某根樑柱有問題，那修復成本將會非常巨大。如果能在每根樑柱完成時就獨立檢查其品質，就能及早發現問題並修正。

**單元測試 (Unit Test)** 就是軟體開發中的「樑柱檢查」。它是一種針對程式碼中**最小可測試單元**（通常是方法或函數）進行驗證的測試方法。每個單元都被獨立於其他組件進行測試，以確保其行為符合預期。

單元測試的重要性體現在：

1.  **及早發現錯誤**：在開發初期就能捕獲程式碼缺陷，降低修復成本。
2.  **提升程式碼品質**：為了方便測試，程式碼會被設計得更加模組化、低耦合，這自然會提高程式碼的可讀性和可維護性。
3.  **提供回歸保障**：當對現有程式碼進行修改或重構時，可以快速運行單元測試，確保這些改動沒有破壞現有的功能（避免「改東牆、倒西牆」）。
4.  **加速開發流程**：雖然撰寫測試需要時間，但長期來看，它能減少手動測試的時間，並提升開發人員對程式碼的信心。
5.  **作為文件**：清晰的單元測試本身就是一份活的程式碼文件，展示了每個單元預期的行為。

---

## 💡 單元測試框架與工具

在 .NET 生態系中，有多種流行的單元測試框架可供選擇：

* **xUnit.net**：
    * 輕量、擴展性強，且是 ASP.NET Core 專案模板預設推薦的測試框架。
    * 語法簡潔，支援資料驅動測試。
* **NUnit**：
    * 歷史悠久、功能豐富，廣泛使用，與 JUnit 相似。
* **MSTest**：
    * 微軟官方提供的測試框架，與 Visual Studio 整合度高。

### 模擬/偽造框架 (Mocking/Faking Frameworks)

由於單元測試強調「獨立性」，當一個單元依賴於其他外部組件（如資料庫、外部 API、其他服務）時，我們需要使用**模擬 (Mocking)** 框架來偽造這些依賴項的行為，避免測試過程中實際訪問外部資源。

* **Moq (Mock Objects)**：
    * 非常流行且功能強大的開源模擬框架，支援 C# 的 Linq-to-objects 語法，使得 Mock 設置非常直觀。
    * 可以用來模擬介面或抽象類別。
* **NSubstitute**：
    * 另一個流行的模擬框架，語法更加簡潔流暢。
* **FakeItEasy**：
    * 靈活易用，也是不錯的選擇。

---

## ⚙️ 為 ASP.NET Core MVC 專案撰寫單元測試

一個典型的 ASP.NET Core MVC 專案，通常會為 **服務層 (Service Layer)** 和 **控制器 (Controller)** 撰寫單元測試。

### 1. 為服務層 (Service Layer) 撰寫單元測試

服務層通常包含應用程式的核心業務邏輯，且不直接依賴於 HTTP 請求上下文，這使得它成為單元測試的理想對象。

假設有一個 `ProductService` 依賴於 `IProductRepository` 介面：

```csharp
// 介面定義
public interface IProductRepository
{
    Task<Product> GetProductByIdAsync(int id);
    Task AddProductAsync(Product product);
}

// 服務層實作
public class ProductService
{
    private readonly IProductRepository _productRepository;

    public ProductService(IProductRepository productRepository)
    {
        _productRepository = productRepository;
    }

    public async Task<Product> GetProductDetailsAsync(int id)
    {
        if (id <= 0)
        {
            throw new ArgumentOutOfRangeException(nameof(id));
        }
        var product = await _productRepository.GetProductByIdAsync(id);
        // 可能有額外的業務邏輯處理
        return product;
    }
}
```

撰寫 `ProductsController` 的單元測試：
```csharp
using Xunit;
using Moq;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using System.Threading.Tasks;
// 假設 Product、ProductService、ProductsController 在相應的命名空間

public class ProductsControllerTests
{
    [Fact]
    public async Task Details_ReturnsViewWithProduct_WhenProductExists()
    {
        // Arrange
        var mockService = new Mock<IProductService>();
        var mockLogger = new Mock<ILogger<ProductsController>>();
        var expectedProduct = new Product { Id = 1, Name = "Test Product" };

        mockService.Setup(s => s.GetProductDetailsAsync(1))
                   .ReturnsAsync(expectedProduct);

        var controller = new ProductsController(mockService.Object, mockLogger.Object);

        // Act
        var result = await controller.Details(1);

        // Assert
        var viewResult = Assert.IsType<ViewResult>(result); // 驗證返回的是 ViewResult
        var model = Assert.IsAssignableFrom<Product>(viewResult.Model); // 驗證 Model 型別
        Assert.Equal(expectedProduct.Id, model.Id);
    }

    [Fact]
    public async Task Details_ReturnsNotFound_WhenProductDoesNotExist()
    {
        // Arrange
        var mockService = new Mock<IProductService>();
        var mockLogger = new Mock<ILogger<ProductsController>>();

        mockService.Setup(s => s.GetProductDetailsAsync(It.IsAny<int>()))
                   .ReturnsAsync((Product)null); // 模擬返回 null

        var controller = new ProductsController(mockService.Object, mockLogger.Object);

        // Act
        var result = await controller.Details(99); // 測試一個不存在的 ID

        // Assert
        Assert.IsType<NotFoundResult>(result); // 驗證返回 404 NotFound
    }

    [Fact]
    public async Task Details_ReturnsBadRequest_WhenIdIsInvalid()
    {
        // Arrange
        var mockService = new Mock<IProductService>();
        var mockLogger = new Mock<ILogger<ProductsController>>();

        // 模擬服務拋出 ArgumentOutOfRangeException
        mockService.Setup(s => s.GetProductDetailsAsync(It.IsAny<int>()))
                   .ThrowsAsync(new ArgumentOutOfRangeException());

        var controller = new ProductsController(mockService.Object, mockLogger.Object);

        // Act
        var result = await controller.Details(-1); // 測試無效 ID

        // Assert
        Assert.IsType<BadRequestResult>(result); // 驗證返回 400 BadRequest
    }
}
```

---
### **💭 應用情境思考：**

在上述 `ProductServiceTests` 範例中，為什麼要使用 `mockRepo.Verify()` 來驗證 `GetProductByIdAsync` 方法是否被呼叫過？這樣做的目的是什麼？

---
## 🚀 將單元測試整合到自動化流程

單元測試的真正價值在於它們被自動化執行。在 CI/CD (持續整合/持續部署) 管線中自動運行單元測試，是現代軟體開發的標準實踐。

### 常見的自動化工具：
- **Azure DevOps Pipelines**
- **GitHub Actions**
- **GitLab CI/CD**
- **Jenkins**

### 自動化步驟概述：
1. **程式碼提交 (Code Commit)**：開發者將程式碼推送到版本控制系統 (如 Git)。
2. **觸發 CI/CD 管線 (Trigger CI/CD Pipeline)**：每次提交或合併到特定分支時，自動化管線被觸發。
3. **建置專案 (Build Project)**：管線會下載程式碼，並使用 `dotnet build` 命令編譯專案。
4. **執行單元測試 (Run Unit Tests)**：使用 `dotnet test` 命令運行專案中的所有單元測試。
    - 可以指定要運行的測試專案。
    - 可以生成測試報告 (如 JUnit XML 格式)。
```csharp
dotnet test YourSolution.sln --logger trx --results-directory "TestResults"
# 或者指定特定測試專案
dotnet test YourSolution.sln --filter "Category=UnitTest"
```
5. **分析測試結果 (Analyze Test Results)**：如果任何單元測試失敗，管線會標記為失敗，並通知開發者。通常會禁止將失敗的程式碼部署到生產環境。
6. **部署 (Deployment)**：只有當所有測試通過後，程式碼才允許被部署到下一環境 (如 Staging, Production)。

透過自動化，團隊可以快速獲得關於程式碼健康狀態的回饋，確保每次部署都基於一個穩定的版本。

---
## 🔗 相關卡片

- [[011.6-CoreMVC-依賴注入與服務註冊]] (DI 是實現單元測試的關鍵)
- [[011.8-CoreMVC-非同步程式設計 (Async Await)]] (非同步方法的測試)
- [[011.15-CoreMVC-部署與維運]] (CI/CD 流程的延伸)
