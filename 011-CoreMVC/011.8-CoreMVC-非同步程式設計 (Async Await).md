---
title: ⚙️ 011.8-CoreMVC-非同步程式設計 (Async Await)
tags:
  - ASP-NET
  - Core
  - MVC
  - CSharp
  - 效能優化
  - 非同步
aliases:
  - Async Await
  - 非同步程式
  - Task
created: 2025-07-07
updated: 2025-07-07
status: 草稿
summary: 深入理解 ASP.NET Core MVC 中的非同步程式設計，包括 async/await 的核心概念、應用情境、常見陷阱與最佳實踐，以提升應用程式效能與響應性。
---

## ⚙️ 為什麼需要非同步程式設計？

想像一個熱門餐廳，如果只有一位主廚（伺服器執行緒），每次都必須等一道菜完全煮好（例如：從資料庫查詢、呼叫外部服務），才能開始準備下一道菜，那麼顧客（網頁請求）的等待時間就會非常長。這會導致網站響應變慢，使用者體驗不佳。

**非同步程式設計**（Asynchronous Programming）就像為這家餐廳引入了聰明的幫手。當幫手們需要等待某些耗時操作（如資料庫回傳資料、第三方 API 響應）時，他們不會傻傻地站在那裡，而是會將手邊的工作交還給主廚，讓主廚去處理其他客人的訂單。一旦等待的任務完成，幫手們會自動回來，從上次暫停的地方繼續工作。這大大提升了餐廳的整體效率和同時服務更多客戶的能力。

在 ASP.NET Core MVC 中，採用非同步程式設計的主要目的是：

1.  **提升應用程式的吞吐量 (Throughput)**：在執行 I/O 密集型操作（如資料庫存取、外部網路請求）時，釋放當前伺服器執行緒回執行緒池，使其能處理其他傳入請求，讓伺服器能同時服務更多使用者。
2.  **改善響應性 (Responsiveness)**：對於長時間運行的操作，避免阻塞處理請求的執行緒，確保應用程式保持快速響應。

---

## 💡 `async` 與 `await`：核心概念解析

在 C# 中，主要透過 **`async`** 和 **`await`** 這兩個關鍵字來實現非同步程式設計。

* **`async` 關鍵字**：
    * 用於標記一個方法為「**非同步方法**」。這表示該方法內部可能包含 `await` 表達式。
    * `async` 本身不代表方法會非同步執行，而是允許方法在遇到 `await` 時，能夠**暫停執行**並將控制權返回給呼叫者，直到被等待的操作完成。
    * `async` 方法的返回型別通常是 `Task`（無返回值）、`Task<TResult>`（有返回值），或在事件處理器中偶爾使用 `void`。

* **`await` 關鍵字**：
    * 只能在 `async` 方法內部使用。
    * 用於等待一個「**可等待 (awaitable)**」的操作完成，最常見的可等待物件是 `Task` 或 `Task<TResult>`。
    * 當執行流程遇到 `await` 時，如果被等待的操作還未完成，目前的**執行緒會被釋放**，回到執行緒池，讓它可以處理其他請求。一旦被等待的操作完成，方法會從上次暫停的地方恢復執行。

**簡單來說：**
在方法前加 `async`，就像是宣告：「這個方法裡可能有需要『等一下』的步驟喔！」
在一個操作前加 `await`，則明確表示：「我要『等』這個操作完成，但等待期間，我會把執行緒讓出來，不阻礙其他任務。」

---

### **💭 應用情境思考：**
考慮一個需要從外部 API 獲取資料的 ASP.NET Core MVC Action 方法。如果該方法沒有使用 `async` 和 `await` 來處理 API 呼叫，可能會對應用程式造成什麼影響？

---

## ⚡️ 常見的非同步操作

在 ASP.NET Core MVC 開發中，許多 I/O 密集型操作都有對應的非同步版本：

* **資料庫操作**：使用 Entity Framework Core (EF Core) 時，應優先使用非同步方法，例如 `ToListAsync()`、`FirstOrDefaultAsync()`、`SaveChangesAsync()` 等。
```csharp
public async Task<IActionResult> Index()
{
    // 傳統同步寫法 (不推薦在Web應用程式中長時間阻塞)
    // var products = _context.Products.ToList(); 
    
    // 非同步寫法，釋放執行緒等待資料庫操作
    var products = await _context.Products.ToListAsync(); 
    return View(products);
}
```

* **網路請求 (HTTP Client)**：當呼叫外部 API 或微服務時，使用 `HttpClient` 的非同步方法。
```csharp
public async Task<string> GetExternalDataAsync(string url)
{
    using (HttpClient client = new HttpClient())
    {
        // 非同步發送 HTTP GET 請求
        string result = await client.GetStringAsync(url);
        return result;
    }
}
```

* **檔案 I/O**：讀寫檔案時，使用非同步方法以避免阻塞。
```csharp
public async Task<string> ReadFileAsync(string path)
{
    // 非同步讀取檔案內容
    string content = await System.IO.File.ReadAllTextAsync(path);
    return content;
}
```

---

## ⚠️ 非同步程式設計的常見陷阱與最佳實踐

雖然非同步程式設計好處多，但也有一些需要注意的「坑」：

1.  **避免混合使用同步與非同步代碼 (Async Over Sync)**：
    * **陷阱**：在 `async` 方法中使用同步等待非同步結果（例如 `Task.Result` 或 `Task.Wait()`)，這會導致**死結 (Deadlock)** 或效能問題。這就像你的主廚說要讓幫手去等，但自己又跟著幫手一起等，結果誰都沒動。
    * **最佳實踐**：從請求的入口點（Controller Action）開始，一直到最底層的資料存取或外部服務呼叫，**都應該使用 `async` 和 `await`**。這稱為「Async All The Way Down」。

2.  **理解 `ConfigureAwait(false)`**：
    * 當 `await` 一個 `Task` 完成後，預設情況下，程式會嘗試在**原來的同步上下文 (Synchronization Context)** 中恢復執行。在 ASP.NET Core 中，這通常不是問題，因為它沒有像舊版 ASP.NET 那樣嚴格的同步上下文。
    * **最佳實踐**：在**函式庫 (Library) 或不依賴特定上下文的通用程式碼**中，使用 `await SomeTask().ConfigureAwait(false);` 可以輕微提升效能並避免潛在死結。但在 **Controller Action 或 View Model** 等需要返回 UI 或特定請求上下文的地方，則**不應該使用 `ConfigureAwait(false)`**，以確保上下文的正確傳遞。

3.  **錯誤處理**：
    * 非同步方法中的例外會被包裝在 `Task` 中。使用 `await` 時，這些例外會像同步方法一樣被重新拋出，可以直接用 `try-catch` 處理。

4.  **取消令牌 (Cancellation Token)**：
    * 對於長時間運行的非同步操作，應考慮引入 `CancellationToken`，允許使用者或系統在必要時**取消操作**，避免資源浪費。
    * 例如：在 Controller Action 接收來自 HTTP 請求的取消訊號。

---

## 🔗 相關卡片

- [[011.11-CoreMVC-效能優化與快取]]
- [[011.6-CoreMVC-依賴注入與服務註冊]] (非同步服務的註冊)
- [[011.7-CoreMVC-與資料庫整合 (EF Core)]]

---