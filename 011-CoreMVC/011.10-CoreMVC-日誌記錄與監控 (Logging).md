---
title: ⚙️ 011.11-CoreMVC-錯誤處理與中介軟體 (Middleware)
tags:
  - ASP-NET
  - Core
  - MVC
  - 錯誤處理
  - Middleware
  - 例外
aliases:
  - ASP.NET Core 錯誤處理
  - 中介軟體
  - Exception Handling
created: 2025-07-07
updated: 2025-07-07
status: 草稿
summary: 深入探討 ASP.NET Core MVC 中間介軟體的概念與其在處理 HTTP 請求管線中的作用，並重點介紹應用程式的錯誤處理策略，包含開發環境與生產環境的最佳實踐。
---

## ⚙️ 什麼是中介軟體 (Middleware)？

想像 ASP.NET Core 應用程式處理每個 HTTP 請求，就像包裹通過一條自動化生產線。每個請求從進入到離開，都會經過一系列的「工作站」，每個工作站負責處理包裹（請求）的某個特定部分。

**中介軟體 (Middleware)** 就是這些「工作站」。它是一個個可以**處理 HTTP 請求和響應的組件**。當一個 HTTP 請求進入 ASP.NET Core 應用程式時，它會按照定義的順序，依序通過這些中介軟體。每個中介軟體都可以選擇：

1.  執行一些邏輯。
2.  將請求傳遞給管線中的下一個中介軟體。
3.  在某些情況下，直接終止管線，並生成響應（例如，發現靜態檔案請求，直接返回檔案）。

這種**鏈式結構 (Chain of Responsibility)** 讓請求處理流程高度模組化和可擴展。

### Middleware 的基本結構

一個中介軟體通常是一個類別或一個委派 (delegate)。簡單來說，它會接收一個 `RequestDelegate`（代表管線中的下一個中介軟體），並返回一個 `Task`。

```csharp
// 範例：一個簡單的自訂中介軟體類別
public class MySimpleMiddleware
{
    private readonly RequestDelegate _next; // 指向管線中的下一個中介軟體

    public MySimpleMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // 在請求進入下一個中介軟體之前執行邏輯
        Console.WriteLine($"[MySimpleMiddleware] Request Path: {context.Request.Path}");

        await _next(context); // 將請求傳遞給管線中的下一個中介軟體

        // 在請求從下一個中介軟體返回之後執行邏輯
        Console.WriteLine($"[MySimpleMiddleware] Response Status: {context.Response.StatusCode}");
    }
}

// 在 Program.cs 中使用這個中介軟體 (擴充方法更簡潔)
public static class MySimpleMiddlewareExtensions
{
    public static IApplicationBuilder UseMySimpleMiddleware(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware<MySimpleMiddleware>();
    }
}
```

### 如何在應用程式中使用中介軟體？

中介軟體通常在 `Program.cs` 檔案（或舊版 .NET Core 的 `Startup.cs` 檔案中的 `Configure` 方法）中定義。

```csharp
// Program.cs
var builder = WebApplication.CreateBuilder(args);
// ... 省略其他服務註冊

var app = builder.Build();

// 中介軟體按照添加順序執行
// 錯誤處理中介軟體通常放在最前面，以便捕獲後續所有的例外
if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage(); // 開發環境專用的錯誤頁面
}
else
{
    app.UseExceptionHandler("/Home/Error"); // 生產環境錯誤處理路徑
    app.UseHsts(); // HSTS 安全標頭
}

app.UseHttpsRedirection(); // HTTP 轉 HTTPS
app.UseStaticFiles();      // 處理 wwwroot 下的靜態檔案
app.UseRouting();          // 路由中介軟體

app.UseAuthentication();   // 身份驗證
app.UseAuthorization();    // 授權

// 自訂中介軟體
// app.UseMySimpleMiddleware(); // 如果有自訂的 MySimpleMiddleware

app.MapControllerRoute(      // MVC 路由終端中介軟體
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");

app.Run();
```

**重要的執行順序：** 中介軟體的註冊順序至關重要！請求會從上到下通過這些中介軟體，然後響應會從下到上返回。這意味著：

- **錯誤處理中介軟體** 通常放在**最前面**，以便捕獲後面所有中介軟體和終端點可能拋出的例外。
- **靜態檔案** 和 **路由** 中介軟體放在錯誤處理之後。
- **身份驗證和授權** 通常放在路由中介軟體之後，終端點中介軟體之前，以確保路由被識別且用戶身份已被驗證。
    

---

### **💭 應用情境思考：**

如果將處理靜態檔案的中介軟體 `UseStaticFiles()` 放置在 `UseRouting()` 之後，可能會導致什麼問題？為什麼？

---

## 💥 ASP.NET Core 的錯誤處理

妥善處理應用程式中的錯誤和例外 (Exceptions) 對於提升用戶體驗和確保系統穩定性至關重要。ASP.NET Core 提供了多種錯誤處理機制。

### 1. 開發環境的錯誤處理

在開發階段，我們希望盡可能詳細地看到錯誤信息，以便快速定位和修復問題。

- **`UseDeveloperExceptionPage()`**：
    
    - 這個中介軟體應該**只在開發環境下使用** (`if (app.Environment.IsDevelopment())`)。
    - 當應用程式發生未處理的例外時，它會顯示一個包含詳細錯誤資訊、堆疊追蹤、查詢字串、Header 等的**開發者友善錯誤頁面**。這對於偵錯非常有幫助。
```csharp
if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage(); // 顯示詳細錯誤資訊
}
```

### 2. 生產環境的錯誤處理

在生產環境中，絕對不能將詳細的錯誤資訊暴露給終端用戶，這可能洩露敏感的系統內部資訊。此時需要提供一個友善的錯誤頁面。

- **`UseExceptionHandler()`**：
    
    - 這個中介軟體用於**生產環境** (`else { app.UseExceptionHandler(...) }`)。
    - 當應用程式發生未處理的例外時，它會重新導向到一個指定的錯誤處理路徑（例如 `/Home/Error` 或 `/Error`）。開發者需要在這個路徑對應的 Controller Action 中，渲染一個友善的錯誤頁面給用戶。
    - 錯誤資訊可以被日誌記錄下來，但不會直接顯示給用戶。
    ```csharp
	else
	{
	    app.UseExceptionHandler("/Home/Error"); // 將所有未處理的例外導向到 /Home/Error 路徑
	    app.UseHsts(); // 啟用 HTTP Strict Transport Security (HSTS)
	}
	```
    - 在 `HomeController` 中，會有一個 `Error` Action：
    ```csharp
    public class HomeController : Controller
	{
	    private readonly ILogger<HomeController> _logger;

	    public HomeController(ILogger<HomeController> logger)
	    {
	        _logger = logger;
	    }

	    [ResponseCache(Duration = 0, Location = ResponseCacheLocation.None, NoStore = true)]
	    public IActionResult Error()
	    {
	        // 獲取原始例外資訊 (只用於日誌記錄，不展示給用戶)
	        var exceptionHandlerPathFeature = HttpContext.Features.Get<IExceptionHandlerPathFeature>();
	        if (exceptionHandlerPathFeature?.Error != null)
	        {
	            _logger.LogError(exceptionHandlerPathFeature.Error, "An unhandled exception occurred at: {Path}", exceptionHandlerPathFeature.Path);
	        }

	        // 傳遞錯誤請求 ID 或其他通用訊息給 View
	        return View(new ErrorViewModel { RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier });
	    }
	}
	```

### 3. 使用 `try-catch` 區塊

對於特定、可預期的錯誤，應該在程式碼中使用標準的 `try-catch` 區塊來捕獲和處理例外。
```csharp
public IActionResult CreateProduct(Product product)
{
    try
    {
        if (ModelState.IsValid)
        {
            _productService.AddProduct(product);
            return RedirectToAction(nameof(Index));
        }
        return View(product); // 返回表單頁面並顯示驗證錯誤
    }
    catch (InvalidOperationException ex)
    {
        // 記錄特定錯誤，並給用戶友善提示
        _logger.LogError(ex, "Failed to create product due to invalid operation.");
        ModelState.AddModelError("", "無法新增產品，請檢查輸入資料。");
        return View(product);
    }
    catch (Exception ex)
    {
        // 捕獲其他未預期的例外
        _logger.LogCritical(ex, "An unexpected error occurred during product creation.");
        // 可以重新導向到一個通用錯誤頁面或顯示通用錯誤訊息
        return View("GenericError");
    }
}
```

### 4. 針對 API 的錯誤處理

對於 RESTful API，通常不會返回 HTML 錯誤頁面，而是返回結構化的 JSON 錯誤響應，包含錯誤碼和錯誤訊息。

- 可以搭配 `ProblemDetails` RFC 7807 標準來統一 API 錯誤響應格式。
    
- 可以透過自訂中介軟體或 Action Filter 來攔截 API 例外並產生標準響應。
    

---
## 🔗 相關卡片

- [[011.1-CoreMVC-框架介紹與專案結構]] (Middleware 在 `Program.cs` 中的位置)
- [[011.10-CoreMVC-日誌記錄與監控 (Logging)]] (錯誤發生時的日誌記錄)
- [[011.15-CoreMVC-部署與維運]] (生產環境錯誤監控)